import assert from 'assert';
import { isBuildStepBareCommandRun, isBuildStepBareFunctionCall, isBuildStepCommandRun, readAndValidateBuildConfigAsync, } from './BuildConfig.js';
import { BuildFunction } from './BuildFunction.js';
import { BuildStep } from './BuildStep.js';
import { BuildStepInput } from './BuildStepInput.js';
import { BuildStepOutput } from './BuildStepOutput.js';
import { BuildWorkflow } from './BuildWorkflow.js';
import { BuildWorkflowValidator } from './BuildWorkflowValidator.js';
import { BuildStepRuntimeError } from './errors.js';
import { duplicates } from './utils/expodash/duplicates.js';
import { uniq } from './utils/expodash/uniq.js';
export class BuildConfigParser {
    constructor(ctx, { configPath, externalFunctions }) {
        this.ctx = ctx;
        this.validateExternalFunctions(externalFunctions);
        this.configPath = configPath;
        this.externalFunctions = externalFunctions;
    }
    async parseAsync() {
        const config = await readAndValidateBuildConfigAsync(this.configPath, {
            externalFunctionIds: this.getExternalFunctionFullIds(),
        });
        const configBuildFunctions = this.createBuildFunctionsFromConfig(config.functions);
        const buildFunctions = this.mergeBuildFunctionsWithExternal(configBuildFunctions, this.externalFunctions);
        const buildSteps = config.build.steps.map((stepConfig) => this.createBuildStepFromConfig(stepConfig, buildFunctions));
        const workflow = new BuildWorkflow(this.ctx, { buildSteps, buildFunctions });
        new BuildWorkflowValidator(workflow).validate();
        return workflow;
    }
    createBuildStepFromConfig(buildStepConfig, buildFunctions) {
        if (isBuildStepCommandRun(buildStepConfig)) {
            return this.createBuildStepFromBuildStepCommandRun(buildStepConfig);
        }
        else if (isBuildStepBareCommandRun(buildStepConfig)) {
            return this.createBuildStepFromBuildStepBareCommandRun(buildStepConfig);
        }
        else if (isBuildStepBareFunctionCall(buildStepConfig)) {
            return this.createBuildStepFromBuildStepBareFunctionCall(buildFunctions, buildStepConfig);
        }
        else {
            return this.createBuildStepFromBuildStepFunctionCall(buildFunctions, buildStepConfig);
        }
    }
    createBuildStepFromBuildStepCommandRun({ run }) {
        const { id: maybeId, inputs: inputsConfig, outputs: outputsConfig, name, workingDirectory, shell, command, } = run;
        const id = BuildStep.getNewId(maybeId);
        const displayName = BuildStep.getDisplayName({ id, name, command });
        const inputs = inputsConfig && this.createBuildStepInputsFromDefinition(inputsConfig, displayName);
        const outputs = outputsConfig && this.createBuildStepOutputsFromDefinition(outputsConfig, displayName);
        return new BuildStep(this.ctx, {
            id,
            inputs,
            outputs,
            name,
            displayName,
            workingDirectory,
            shell,
            command,
        });
    }
    createBuildStepFromBuildStepBareCommandRun({ run: command, }) {
        const id = BuildStep.getNewId();
        const displayName = BuildStep.getDisplayName({ id, command });
        return new BuildStep(this.ctx, {
            id,
            displayName,
            command,
        });
    }
    createBuildStepFromBuildStepBareFunctionCall(buildFunctions, functionId) {
        const buildFunction = buildFunctions[functionId];
        return buildFunction.createBuildStepFromFunctionCall(this.ctx);
    }
    createBuildStepFromBuildStepFunctionCall(buildFunctions, buildStepFunctionCall) {
        const keys = Object.keys(buildStepFunctionCall);
        assert(keys.length === 1, 'There must be at most one function call in the step (enforced by joi).');
        const functionId = keys[0];
        const buildFunctionCallConfig = buildStepFunctionCall[functionId];
        const buildFunction = buildFunctions[functionId];
        return buildFunction.createBuildStepFromFunctionCall(this.ctx, {
            id: buildFunctionCallConfig.id,
            name: buildFunctionCallConfig.name,
            callInputs: buildFunctionCallConfig.inputs,
            workingDirectory: buildFunctionCallConfig.workingDirectory,
            shell: buildFunctionCallConfig.shell,
        });
    }
    createBuildFunctionsFromConfig(buildFunctionsConfig) {
        if (!buildFunctionsConfig) {
            return {};
        }
        const result = {};
        for (const [functionId, buildFunctionConfig] of Object.entries(buildFunctionsConfig)) {
            const buildFunction = this.createBuildFunctionFromConfig({
                id: functionId,
                ...buildFunctionConfig,
            });
            result[buildFunction.getFullId()] = buildFunction;
        }
        return result;
    }
    createBuildFunctionFromConfig({ id, name, inputs: inputsConfig, outputs: outputsConfig, shell, command, supportedRuntimePlatforms, }) {
        const inputProviders = inputsConfig && this.createBuildStepInputProvidersFromBuildFunctionInputs(inputsConfig);
        const outputProviders = outputsConfig && this.createBuildStepOutputProvidersFromBuildFunctionOutputs(outputsConfig);
        return new BuildFunction({
            id,
            name,
            inputProviders,
            outputProviders,
            shell,
            command,
            supportedRuntimePlatforms,
        });
    }
    createBuildStepInputsFromDefinition(buildStepInputs, stepDisplayName) {
        return Object.entries(buildStepInputs).map(([key, value]) => new BuildStepInput(this.ctx, {
            id: key,
            stepDisplayName,
            defaultValue: value,
            required: true,
        }));
    }
    createBuildStepInputProvidersFromBuildFunctionInputs(buildFunctionInputs) {
        return buildFunctionInputs.map((entry) => {
            var _a;
            return typeof entry === 'string'
                ? BuildStepInput.createProvider({ id: entry })
                : BuildStepInput.createProvider({
                    id: entry.name,
                    required: (_a = entry.required) !== null && _a !== void 0 ? _a : true,
                    defaultValue: entry.defaultValue,
                    allowedValues: entry.allowedValues,
                });
        });
    }
    createBuildStepOutputsFromDefinition(buildStepOutputs, stepDisplayName) {
        return buildStepOutputs.map((entry) => {
            var _a;
            return typeof entry === 'string'
                ? new BuildStepOutput(this.ctx, { id: entry, stepDisplayName, required: true })
                : new BuildStepOutput(this.ctx, {
                    id: entry.name,
                    stepDisplayName,
                    required: (_a = entry.required) !== null && _a !== void 0 ? _a : true,
                });
        });
    }
    createBuildStepOutputProvidersFromBuildFunctionOutputs(buildFunctionOutputs) {
        return buildFunctionOutputs.map((entry) => {
            var _a;
            return typeof entry === 'string'
                ? BuildStepOutput.createProvider({ id: entry, required: true })
                : BuildStepOutput.createProvider({ id: entry.name, required: (_a = entry.required) !== null && _a !== void 0 ? _a : true });
        });
    }
    mergeBuildFunctionsWithExternal(configFunctions, externalFunctions) {
        const result = { ...configFunctions };
        if (externalFunctions === undefined) {
            return result;
        }
        for (const buildFunction of externalFunctions) {
            // functions defined in config shadow the external ones
            const fullId = buildFunction.getFullId();
            if (!(fullId in result)) {
                result[fullId] = buildFunction;
            }
        }
        return result;
    }
    validateExternalFunctions(externalFunctions) {
        if (externalFunctions === undefined) {
            return;
        }
        const externalFunctionIds = externalFunctions.map((f) => f.getFullId());
        const duplicatedExternalFunctionIds = duplicates(externalFunctionIds);
        if (duplicatedExternalFunctionIds.length === 0) {
            return;
        }
        throw new BuildStepRuntimeError(`Provided external functions with duplicated IDs: ${duplicatedExternalFunctionIds
            .map((id) => `"${id}"`)
            .join(', ')}`);
    }
    getExternalFunctionFullIds() {
        if (this.externalFunctions === undefined) {
            return [];
        }
        const ids = this.externalFunctions.map((f) => f.getFullId());
        return uniq(ids);
    }
}
//# sourceMappingURL=BuildConfigParser.js.map