"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildStep = exports.BuildStepLogMarker = exports.BuildStepStatus = void 0;
const assert_1 = __importDefault(require("assert"));
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
const BuildStepInput_js_1 = require("./BuildStepInput.cjs");
const BuildStepOutput_js_1 = require("./BuildStepOutput.cjs");
const bin_js_1 = require("./utils/shell/bin.cjs");
const command_js_1 = require("./utils/shell/command.cjs");
const BuildTemporaryFiles_js_1 = require("./BuildTemporaryFiles.cjs");
const spawn_js_1 = require("./utils/shell/spawn.cjs");
const template_js_1 = require("./utils/template.cjs");
const errors_js_1 = require("./errors.cjs");
var BuildStepStatus;
(function (BuildStepStatus) {
    BuildStepStatus["NEW"] = "new";
    BuildStepStatus["IN_PROGRESS"] = "in-progress";
    BuildStepStatus["CANCELED"] = "canceled";
    BuildStepStatus["FAIL"] = "fail";
    BuildStepStatus["WARNING"] = "warning";
    BuildStepStatus["SUCCESS"] = "success";
})(BuildStepStatus = exports.BuildStepStatus || (exports.BuildStepStatus = {}));
var BuildStepLogMarker;
(function (BuildStepLogMarker) {
    BuildStepLogMarker["START_STEP"] = "start-step";
    BuildStepLogMarker["END_STEP"] = "end-step";
})(BuildStepLogMarker = exports.BuildStepLogMarker || (exports.BuildStepLogMarker = {}));
// TODO: move to a place common with tests
const UUID_REGEX = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/;
class BuildStep {
    static getNewId(userDefinedId) {
        return userDefinedId !== null && userDefinedId !== void 0 ? userDefinedId : (0, uuid_1.v4)();
    }
    static getDisplayName({ id, name, command, }) {
        if (name) {
            return name;
        }
        if (!id.match(UUID_REGEX)) {
            return id;
        }
        if (command) {
            const splits = command.trim().split('\n');
            for (const split of splits) {
                const trimmed = split.trim();
                if (trimmed && !trimmed.startsWith('#')) {
                    return trimmed;
                }
            }
        }
        return id;
    }
    constructor(ctx, { id, name, displayName, inputs, outputs, command, fn, workingDirectory: maybeWorkingDirectory, shell, supportedRuntimePlatforms: maybeSupportedRuntimePlatforms, }) {
        this.executed = false;
        (0, assert_1.default)(command !== undefined || fn !== undefined, 'Either command or fn must be defined.');
        (0, assert_1.default)(!(command !== undefined && fn !== undefined), 'Command and fn cannot be both set.');
        this.id = id;
        this.name = name;
        this.displayName = displayName;
        this.supportedRuntimePlatforms = maybeSupportedRuntimePlatforms;
        this.inputs = inputs;
        this.outputs = outputs;
        this.inputById = (0, BuildStepInput_js_1.makeBuildStepInputByIdMap)(inputs);
        this.outputById = (0, BuildStepOutput_js_1.makeBuildStepOutputByIdMap)(outputs);
        this.fn = fn;
        this.command = command;
        this.shell = shell !== null && shell !== void 0 ? shell : (0, command_js_1.getDefaultShell)();
        this.status = BuildStepStatus.NEW;
        this.internalId = (0, uuid_1.v4)();
        const logger = ctx.logger.child({
            buildStepInternalId: this.internalId,
            buildStepId: this.id,
            buildStepDisplayName: this.displayName,
        });
        const workingDirectory = maybeWorkingDirectory !== undefined
            ? path_1.default.resolve(ctx.workingDirectory, maybeWorkingDirectory)
            : ctx.workingDirectory;
        this.ctx = ctx.child({ logger, workingDirectory });
        ctx.registerStep(this);
    }
    async executeAsync(env = process.env) {
        try {
            this.ctx.logger.info({ marker: BuildStepLogMarker.START_STEP }, `Executing build step "${this.displayName}"`);
            this.status = BuildStepStatus.IN_PROGRESS;
            if (this.command !== undefined) {
                await this.executeCommandAsync(env);
            }
            else {
                await this.exectuteFnAsync(env);
            }
            this.ctx.logger.info({ marker: BuildStepLogMarker.END_STEP, result: BuildStepStatus.SUCCESS }, `Finished build step "${this.displayName}" successfully`);
            this.status = BuildStepStatus.SUCCESS;
        }
        catch (err) {
            this.ctx.logger.error({ err });
            this.ctx.logger.error({ marker: BuildStepLogMarker.END_STEP, result: BuildStepStatus.FAIL }, `Build step "${this.displayName}" failed`);
            this.status = BuildStepStatus.FAIL;
            throw err;
        }
        finally {
            this.executed = true;
        }
    }
    hasOutputParameter(name) {
        return name in this.outputById;
    }
    getOutputValueByName(name) {
        if (!this.executed) {
            throw new errors_js_1.BuildStepRuntimeError(`Failed getting output "${name}" from step "${this.displayName}". The step has not been executed yet.`);
        }
        if (!this.hasOutputParameter(name)) {
            throw new errors_js_1.BuildStepRuntimeError(`Step "${this.displayName}" does not have output "${name}".`);
        }
        return this.outputById[name].value;
    }
    canBeRunOnRuntimePlatform() {
        return (!this.supportedRuntimePlatforms ||
            this.supportedRuntimePlatforms.includes(this.ctx.runtimePlatform));
    }
    async executeCommandAsync(env) {
        (0, assert_1.default)(this.command, 'Command must be defined.');
        try {
            const command = this.interpolateInputsInCommand(this.command, this.inputs);
            this.ctx.logger.debug(`Interpolated inputs in the command template`);
            const outputsDir = await (0, BuildTemporaryFiles_js_1.createTemporaryOutputsDirectoryAsync)(this.ctx, this.id);
            this.ctx.logger.debug(`Created temporary directory for step outputs: ${outputsDir}`);
            const scriptPath = await (0, BuildTemporaryFiles_js_1.saveScriptToTemporaryFileAsync)(this.ctx, this.id, command);
            this.ctx.logger.debug(`Saved script to ${scriptPath}`);
            const { command: shellCommand, args } = (0, command_js_1.getShellCommandAndArgs)(this.shell, scriptPath);
            this.ctx.logger.debug(`Executing script: ${shellCommand}${args !== undefined ? ` ${args.join(' ')}` : ''}`);
            await (0, spawn_js_1.spawnAsync)(shellCommand, args !== null && args !== void 0 ? args : [], {
                cwd: this.ctx.workingDirectory,
                logger: this.ctx.logger,
                env: this.getScriptEnv(env, outputsDir),
            });
            this.ctx.logger.debug(`Script completed successfully`);
            await this.collectAndValidateOutputsAsync(outputsDir);
            this.ctx.logger.debug('Finished collecting output paramters');
        }
        finally {
            await (0, BuildTemporaryFiles_js_1.cleanUpStepTemporaryDirectoriesAsync)(this.ctx, this.id);
        }
    }
    async exectuteFnAsync(env) {
        (0, assert_1.default)(this.fn, 'Function (fn) must be defined');
        await this.fn(this.ctx, { inputs: this.inputById, outputs: this.outputById, env });
    }
    interpolateInputsInCommand(command, inputs) {
        if (!inputs) {
            return command;
        }
        const vars = inputs.reduce((acc, input) => {
            var _a;
            acc[input.id] = (_a = input.value) !== null && _a !== void 0 ? _a : '';
            return acc;
        }, {});
        return (0, template_js_1.interpolateWithInputs)(command, vars);
    }
    async collectAndValidateOutputsAsync(outputsDir) {
        var _a;
        const files = await promises_1.default.readdir(outputsDir);
        const nonDefinedOutputIds = [];
        for (const outputId of files) {
            if (!(outputId in this.outputById)) {
                nonDefinedOutputIds.push(outputId);
            }
            else {
                const file = path_1.default.join(outputsDir, outputId);
                const rawContents = await promises_1.default.readFile(file, 'utf-8');
                const value = rawContents.trim();
                this.outputById[outputId].set(value);
            }
        }
        if (nonDefinedOutputIds.length > 0) {
            const idsString = nonDefinedOutputIds.map((i) => `"${i}"`).join(', ');
            this.ctx.logger.warn(`Some outputs are not defined in step config: ${idsString}`);
        }
        const nonSetRequiredOutputIds = [];
        for (const output of (_a = this.outputs) !== null && _a !== void 0 ? _a : []) {
            try {
                const value = output.value;
                this.ctx.logger.debug(`Output parameter "${output.id}" is set to "${value}"`);
            }
            catch (err) {
                this.ctx.logger.debug({ err }, `Getting value for output parameter "${output.id}" failed.`);
                nonSetRequiredOutputIds.push(output.id);
            }
        }
        if (nonSetRequiredOutputIds.length > 0) {
            const idsString = nonSetRequiredOutputIds.map((i) => `"${i}"`).join(', ');
            throw new errors_js_1.BuildStepRuntimeError(`Some required outputs have not been set: ${idsString}`, {
                metadata: { ids: nonSetRequiredOutputIds },
            });
        }
    }
    getScriptEnv(env, outputsDir) {
        var _a;
        const currentPath = (_a = env.PATH) !== null && _a !== void 0 ? _a : process.env.PATH;
        const newPath = currentPath ? `${bin_js_1.BIN_PATH}:${currentPath}` : bin_js_1.BIN_PATH;
        return {
            ...env,
            __EXPO_STEPS_BUILD_ID: this.ctx.buildId,
            __EXPO_STEPS_OUTPUTS_DIR: outputsDir,
            __EXPO_STEPS_WORKING_DIRECTORY: this.ctx.workingDirectory,
            PATH: newPath,
        };
    }
}
exports.BuildStep = BuildStep;
//# sourceMappingURL=BuildStep.js.map