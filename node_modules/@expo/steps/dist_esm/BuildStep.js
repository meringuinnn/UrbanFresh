import assert from 'assert';
import fs from 'fs/promises';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { makeBuildStepInputByIdMap } from './BuildStepInput.js';
import { makeBuildStepOutputByIdMap, } from './BuildStepOutput.js';
import { BIN_PATH } from './utils/shell/bin.js';
import { getDefaultShell, getShellCommandAndArgs } from './utils/shell/command.js';
import { cleanUpStepTemporaryDirectoriesAsync, createTemporaryOutputsDirectoryAsync, saveScriptToTemporaryFileAsync, } from './BuildTemporaryFiles.js';
import { spawnAsync } from './utils/shell/spawn.js';
import { interpolateWithInputs } from './utils/template.js';
import { BuildStepRuntimeError } from './errors.js';
export var BuildStepStatus;
(function (BuildStepStatus) {
    BuildStepStatus["NEW"] = "new";
    BuildStepStatus["IN_PROGRESS"] = "in-progress";
    BuildStepStatus["CANCELED"] = "canceled";
    BuildStepStatus["FAIL"] = "fail";
    BuildStepStatus["WARNING"] = "warning";
    BuildStepStatus["SUCCESS"] = "success";
})(BuildStepStatus || (BuildStepStatus = {}));
export var BuildStepLogMarker;
(function (BuildStepLogMarker) {
    BuildStepLogMarker["START_STEP"] = "start-step";
    BuildStepLogMarker["END_STEP"] = "end-step";
})(BuildStepLogMarker || (BuildStepLogMarker = {}));
// TODO: move to a place common with tests
const UUID_REGEX = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/;
export class BuildStep {
    static getNewId(userDefinedId) {
        return userDefinedId !== null && userDefinedId !== void 0 ? userDefinedId : uuidv4();
    }
    static getDisplayName({ id, name, command, }) {
        if (name) {
            return name;
        }
        if (!id.match(UUID_REGEX)) {
            return id;
        }
        if (command) {
            const splits = command.trim().split('\n');
            for (const split of splits) {
                const trimmed = split.trim();
                if (trimmed && !trimmed.startsWith('#')) {
                    return trimmed;
                }
            }
        }
        return id;
    }
    constructor(ctx, { id, name, displayName, inputs, outputs, command, fn, workingDirectory: maybeWorkingDirectory, shell, supportedRuntimePlatforms: maybeSupportedRuntimePlatforms, }) {
        this.executed = false;
        assert(command !== undefined || fn !== undefined, 'Either command or fn must be defined.');
        assert(!(command !== undefined && fn !== undefined), 'Command and fn cannot be both set.');
        this.id = id;
        this.name = name;
        this.displayName = displayName;
        this.supportedRuntimePlatforms = maybeSupportedRuntimePlatforms;
        this.inputs = inputs;
        this.outputs = outputs;
        this.inputById = makeBuildStepInputByIdMap(inputs);
        this.outputById = makeBuildStepOutputByIdMap(outputs);
        this.fn = fn;
        this.command = command;
        this.shell = shell !== null && shell !== void 0 ? shell : getDefaultShell();
        this.status = BuildStepStatus.NEW;
        this.internalId = uuidv4();
        const logger = ctx.logger.child({
            buildStepInternalId: this.internalId,
            buildStepId: this.id,
            buildStepDisplayName: this.displayName,
        });
        const workingDirectory = maybeWorkingDirectory !== undefined
            ? path.resolve(ctx.workingDirectory, maybeWorkingDirectory)
            : ctx.workingDirectory;
        this.ctx = ctx.child({ logger, workingDirectory });
        ctx.registerStep(this);
    }
    async executeAsync(env = process.env) {
        try {
            this.ctx.logger.info({ marker: BuildStepLogMarker.START_STEP }, `Executing build step "${this.displayName}"`);
            this.status = BuildStepStatus.IN_PROGRESS;
            if (this.command !== undefined) {
                await this.executeCommandAsync(env);
            }
            else {
                await this.exectuteFnAsync(env);
            }
            this.ctx.logger.info({ marker: BuildStepLogMarker.END_STEP, result: BuildStepStatus.SUCCESS }, `Finished build step "${this.displayName}" successfully`);
            this.status = BuildStepStatus.SUCCESS;
        }
        catch (err) {
            this.ctx.logger.error({ err });
            this.ctx.logger.error({ marker: BuildStepLogMarker.END_STEP, result: BuildStepStatus.FAIL }, `Build step "${this.displayName}" failed`);
            this.status = BuildStepStatus.FAIL;
            throw err;
        }
        finally {
            this.executed = true;
        }
    }
    hasOutputParameter(name) {
        return name in this.outputById;
    }
    getOutputValueByName(name) {
        if (!this.executed) {
            throw new BuildStepRuntimeError(`Failed getting output "${name}" from step "${this.displayName}". The step has not been executed yet.`);
        }
        if (!this.hasOutputParameter(name)) {
            throw new BuildStepRuntimeError(`Step "${this.displayName}" does not have output "${name}".`);
        }
        return this.outputById[name].value;
    }
    canBeRunOnRuntimePlatform() {
        return (!this.supportedRuntimePlatforms ||
            this.supportedRuntimePlatforms.includes(this.ctx.runtimePlatform));
    }
    async executeCommandAsync(env) {
        assert(this.command, 'Command must be defined.');
        try {
            const command = this.interpolateInputsInCommand(this.command, this.inputs);
            this.ctx.logger.debug(`Interpolated inputs in the command template`);
            const outputsDir = await createTemporaryOutputsDirectoryAsync(this.ctx, this.id);
            this.ctx.logger.debug(`Created temporary directory for step outputs: ${outputsDir}`);
            const scriptPath = await saveScriptToTemporaryFileAsync(this.ctx, this.id, command);
            this.ctx.logger.debug(`Saved script to ${scriptPath}`);
            const { command: shellCommand, args } = getShellCommandAndArgs(this.shell, scriptPath);
            this.ctx.logger.debug(`Executing script: ${shellCommand}${args !== undefined ? ` ${args.join(' ')}` : ''}`);
            await spawnAsync(shellCommand, args !== null && args !== void 0 ? args : [], {
                cwd: this.ctx.workingDirectory,
                logger: this.ctx.logger,
                env: this.getScriptEnv(env, outputsDir),
            });
            this.ctx.logger.debug(`Script completed successfully`);
            await this.collectAndValidateOutputsAsync(outputsDir);
            this.ctx.logger.debug('Finished collecting output paramters');
        }
        finally {
            await cleanUpStepTemporaryDirectoriesAsync(this.ctx, this.id);
        }
    }
    async exectuteFnAsync(env) {
        assert(this.fn, 'Function (fn) must be defined');
        await this.fn(this.ctx, { inputs: this.inputById, outputs: this.outputById, env });
    }
    interpolateInputsInCommand(command, inputs) {
        if (!inputs) {
            return command;
        }
        const vars = inputs.reduce((acc, input) => {
            var _a;
            acc[input.id] = (_a = input.value) !== null && _a !== void 0 ? _a : '';
            return acc;
        }, {});
        return interpolateWithInputs(command, vars);
    }
    async collectAndValidateOutputsAsync(outputsDir) {
        var _a;
        const files = await fs.readdir(outputsDir);
        const nonDefinedOutputIds = [];
        for (const outputId of files) {
            if (!(outputId in this.outputById)) {
                nonDefinedOutputIds.push(outputId);
            }
            else {
                const file = path.join(outputsDir, outputId);
                const rawContents = await fs.readFile(file, 'utf-8');
                const value = rawContents.trim();
                this.outputById[outputId].set(value);
            }
        }
        if (nonDefinedOutputIds.length > 0) {
            const idsString = nonDefinedOutputIds.map((i) => `"${i}"`).join(', ');
            this.ctx.logger.warn(`Some outputs are not defined in step config: ${idsString}`);
        }
        const nonSetRequiredOutputIds = [];
        for (const output of (_a = this.outputs) !== null && _a !== void 0 ? _a : []) {
            try {
                const value = output.value;
                this.ctx.logger.debug(`Output parameter "${output.id}" is set to "${value}"`);
            }
            catch (err) {
                this.ctx.logger.debug({ err }, `Getting value for output parameter "${output.id}" failed.`);
                nonSetRequiredOutputIds.push(output.id);
            }
        }
        if (nonSetRequiredOutputIds.length > 0) {
            const idsString = nonSetRequiredOutputIds.map((i) => `"${i}"`).join(', ');
            throw new BuildStepRuntimeError(`Some required outputs have not been set: ${idsString}`, {
                metadata: { ids: nonSetRequiredOutputIds },
            });
        }
    }
    getScriptEnv(env, outputsDir) {
        var _a;
        const currentPath = (_a = env.PATH) !== null && _a !== void 0 ? _a : process.env.PATH;
        const newPath = currentPath ? `${BIN_PATH}:${currentPath}` : BIN_PATH;
        return {
            ...env,
            __EXPO_STEPS_BUILD_ID: this.ctx.buildId,
            __EXPO_STEPS_OUTPUTS_DIR: outputsDir,
            __EXPO_STEPS_WORKING_DIRECTORY: this.ctx.workingDirectory,
            PATH: newPath,
        };
    }
}
//# sourceMappingURL=BuildStep.js.map