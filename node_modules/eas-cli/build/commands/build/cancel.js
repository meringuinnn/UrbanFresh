"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectBuildToCancelAsync = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const graphql_tag_1 = tslib_1.__importDefault(require("graphql-tag"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const client_1 = require("../../graphql/client");
const generated_1 = require("../../graphql/generated");
const BuildQuery_1 = require("../../graphql/queries/BuildQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const ora_1 = require("../../ora");
const platform_1 = require("../../platform");
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
async function cancelBuildAsync(graphqlClient, buildId) {
    const data = await (0, client_1.withErrorHandlingAsync)(graphqlClient
        .mutation((0, graphql_tag_1.default) `
          mutation CancelBuildMutation($buildId: ID!) {
            build(buildId: $buildId) {
              cancel {
                id
                status
              }
            }
          }
        `, { buildId })
        .toPromise());
    return data.build.cancel;
}
function formatUnfinishedBuild(build) {
    const platform = platform_1.appPlatformEmojis[build.platform];
    const startTime = new Date(build.createdAt).toLocaleString();
    let statusText;
    if (build.status === generated_1.BuildStatus.New) {
        statusText = 'new';
    }
    else if (build.status === generated_1.BuildStatus.InQueue) {
        statusText = 'in queue';
    }
    else {
        statusText = 'in progress';
    }
    const status = chalk_1.default.blue(statusText);
    return `${platform} Started at: ${startTime}, Status: ${status}, Id: ${build.id}`;
}
async function selectBuildToCancelAsync(graphqlClient, projectId, projectDisplayName) {
    const spinner = (0, ora_1.ora)().start('Fetching the uncompleted builds…');
    let builds;
    try {
        const [newBuilds, inQueueBuilds, inProgressBuilds] = await Promise.all([
            BuildQuery_1.BuildQuery.viewBuildsOnAppAsync(graphqlClient, {
                appId: projectId,
                offset: 0,
                limit: 10,
                filter: { status: generated_1.BuildStatus.New },
            }),
            BuildQuery_1.BuildQuery.viewBuildsOnAppAsync(graphqlClient, {
                appId: projectId,
                offset: 0,
                limit: 10,
                filter: { status: generated_1.BuildStatus.InQueue },
            }),
            BuildQuery_1.BuildQuery.viewBuildsOnAppAsync(graphqlClient, {
                appId: projectId,
                offset: 0,
                limit: 10,
                filter: { status: generated_1.BuildStatus.InProgress },
            }),
        ]);
        spinner.stop();
        builds = [...newBuilds, ...inQueueBuilds, ...inProgressBuilds];
    }
    catch (error) {
        spinner.fail(`Something went wrong and we couldn't fetch the builds for the project ${projectDisplayName}.`);
        throw error;
    }
    if (builds.length === 0) {
        log_1.default.warn(`There aren't any uncompleted builds for the project ${projectDisplayName}.`);
        return null;
    }
    else {
        const buildId = await (0, prompts_1.selectAsync)('Which build do you want to cancel?', builds.map(build => ({
            title: formatUnfinishedBuild(build),
            value: build.id,
        })));
        return (await (0, prompts_1.confirmAsync)({
            message: 'Are you sure you want to cancel it?',
        }))
            ? buildId
            : null;
    }
}
exports.selectBuildToCancelAsync = selectBuildToCancelAsync;
async function ensureBuildExistsAsync(graphqlClient, buildId) {
    try {
        await BuildQuery_1.BuildQuery.byIdAsync(graphqlClient, buildId);
    }
    catch {
        throw new Error(`Couldn't find a build matching the id ${buildId}`);
    }
}
class BuildCancel extends EasCommand_1.default {
    async runAsync() {
        const { args: { BUILD_ID: buildIdFromArg }, flags: { 'non-interactive': nonInteractive }, } = await this.parse(BuildCancel);
        const { privateProjectConfig: { projectId }, loggedIn: { graphqlClient }, } = await this.getContextAsync(BuildCancel, {
            nonInteractive,
        });
        const displayName = await (0, projectUtils_1.getDisplayNameForProjectIdAsync)(graphqlClient, projectId);
        if (buildIdFromArg) {
            await ensureBuildExistsAsync(graphqlClient, buildIdFromArg);
        }
        let buildId = buildIdFromArg;
        if (!buildId) {
            if (nonInteractive) {
                throw new Error('BUILD_ID must not be empty in non-interactive mode');
            }
            buildId = await selectBuildToCancelAsync(graphqlClient, projectId, displayName);
            if (!buildId) {
                return;
            }
        }
        const spinner = (0, ora_1.ora)().start('Canceling the build…');
        try {
            const { status } = await cancelBuildAsync(graphqlClient, buildId);
            if ([generated_1.BuildStatus.Canceled, generated_1.BuildStatus.PendingCancel].includes(status)) {
                spinner.succeed('Build canceled');
            }
            else {
                spinner.text = 'Build is already completed';
                spinner.stopAndPersist();
            }
        }
        catch (error) {
            spinner.fail(`Something went wrong and we couldn't cancel your build ${buildId}`);
            throw error;
        }
    }
}
exports.default = BuildCancel;
_a = BuildCancel;
BuildCancel.description = 'cancel a build';
BuildCancel.args = [{ name: 'BUILD_ID' }];
BuildCancel.flags = {
    ...flags_1.EASNonInteractiveFlag,
};
BuildCancel.contextDefinition = {
    ..._a.ContextOptions.ProjectConfig,
    ..._a.ContextOptions.LoggedIn,
};
