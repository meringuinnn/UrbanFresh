"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const queries_1 = require("../../branch/queries");
const queries_2 = require("../../channel/queries");
const utils_1 = require("../../channel/utils");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const BranchQuery_1 = require("../../graphql/queries/BranchQuery");
const ChannelQuery_1 = require("../../graphql/queries/ChannelQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
const json_1 = require("../../utils/json");
const edit_1 = require("./edit");
async function promptForRolloutPercentAsync({ promptMessage, }) {
    const { name: rolloutPercent } = await (0, prompts_1.promptAsync)({
        type: 'text',
        name: 'name',
        format: value => {
            return parseInt(value, 10);
        },
        message: promptMessage,
        initial: 0,
        validate: (rolloutPercent) => {
            const floatValue = parseFloat(rolloutPercent);
            return Number.isInteger(floatValue) && floatValue >= 0 && floatValue <= 100
                ? true
                : 'The rollout percentage must be an integer between 0 and 100 inclusive.';
        },
    });
    return rolloutPercent;
}
function getRolloutInfo(channel) {
    const { branchMapping } = (0, utils_1.getBranchMapping)(channel.branchMapping);
    const [newBranchId, oldBranchId] = branchMapping.data.map(d => d.branchId);
    const newBranch = channel.updateBranches.filter(branch => branch.id === newBranchId)[0];
    const oldBranch = channel.updateBranches.filter(branch => branch.id === oldBranchId)[0];
    if (!newBranch || !oldBranch) {
        throw new Error(`Branch mapping rollout is missing a branch for channel "${channel.name}".`);
    }
    const currentPercent = 100 * branchMapping.data[0].branchMappingLogic.operand;
    return { newBranch, oldBranch, currentPercent };
}
async function startRolloutAsync(graphqlClient, { channelName, branchName, percent, projectId, displayName, currentBranchMapping, channel, nonInteractive, }) {
    const branch = await BranchQuery_1.BranchQuery.getBranchByNameAsync(graphqlClient, {
        appId: projectId,
        name: branchName,
    });
    const oldBranchId = currentBranchMapping.data[0].branchId;
    if (branch.id === oldBranchId) {
        throw new Error(`channel "${channelName}" is already pointing at branch "${branchName}". Rollouts must be done with distinct branches.`);
    }
    if (percent == null) {
        if (nonInteractive) {
            throw new Error('You must specify a percent with the --percent flag when initiating a rollout with the --non-interactive flag.');
        }
        const promptMessage = `What percent of users should be directed to the branch "${branchName}"?`;
        percent = await promptForRolloutPercentAsync({ promptMessage });
    }
    const newBranchMapping = {
        version: 0,
        data: [
            {
                branchId: branch.id,
                branchMappingLogic: {
                    operand: percent / 100,
                    clientKey: 'rolloutToken',
                    branchMappingOperator: 'hash_lt',
                },
            },
            currentBranchMapping.data[0],
        ],
    };
    const newChannelInfo = await (0, edit_1.updateChannelBranchMappingAsync)(graphqlClient, {
        channelId: channel.id,
        branchMapping: JSON.stringify(newBranchMapping),
    });
    const oldBranch = channel.updateBranches.filter(branch => branch.id === oldBranchId)[0];
    if (!oldBranch) {
        throw new Error(`Branch mapping is missing its only branch for channel "${channelName}" on app "${displayName}"`);
    }
    const logMessage = `Started a rollout of branch ${chalk_1.default.bold(branchName)} on channel ${chalk_1.default.bold(channelName)}! ${chalk_1.default.bold(percent)}% of users will be directed to branch ${chalk_1.default.bold(branchName)}, ${chalk_1.default.bold(100 - percent)}% to branch ${chalk_1.default.bold(oldBranch.name)}.`;
    return { newChannelInfo, logMessage };
}
async function editRolloutAsync(graphqlClient, { channelName, percent, nonInteractive, currentBranchMapping, channel, }) {
    const { newBranch, oldBranch, currentPercent } = getRolloutInfo(channel);
    if (percent == null) {
        if (nonInteractive) {
            throw new Error('A rollout is already in progress. If you wish to modify it you must use specify the new rollout percentage with the --percent flag.');
        }
        const promptMessage = `Currently ${currentPercent}% of all users are routed to branch ${newBranch.name} and ${100 - currentPercent}% of all users are routed to branch ${oldBranch.name}. What percent of users should be directed to the branch ${newBranch.name}?`;
        percent = await promptForRolloutPercentAsync({ promptMessage });
    }
    const newBranchMapping = { ...currentBranchMapping };
    newBranchMapping.data[0].branchMappingLogic.operand = percent / 100;
    const newChannelInfo = await (0, edit_1.updateChannelBranchMappingAsync)(graphqlClient, {
        channelId: channel.id,
        branchMapping: JSON.stringify(newBranchMapping),
    });
    const logMessage = `Rollout of branch ${chalk_1.default.bold(newBranch.name)} on channel ${chalk_1.default.bold(channelName)} updated from ${chalk_1.default.bold(currentPercent)}% to ${chalk_1.default.bold(percent)}%. ${chalk_1.default.bold(percent)}% of users will be directed to branch ${chalk_1.default.bold(newBranch.name)}, ${chalk_1.default.bold(100 - percent)}% to branch ${chalk_1.default.bold(oldBranch.name)}.`;
    return { newChannelInfo, logMessage };
}
async function endRolloutAsync(graphqlClient, { channelName, branchName, nonInteractive, projectId, channel, }) {
    // end rollout
    const { newBranch, oldBranch, currentPercent } = getRolloutInfo(channel);
    let endOnNewBranch;
    if (branchName) {
        const branch = await BranchQuery_1.BranchQuery.getBranchByNameAsync(graphqlClient, {
            appId: projectId,
            name: branchName,
        });
        switch (branch.id) {
            case newBranch.id:
                endOnNewBranch = true;
                break;
            case oldBranch.id:
                endOnNewBranch = false;
                break;
            default:
                throw new Error(`The branch "${branchName}" specified by --branch must be one of the branches involved in the rollout: "${newBranch.name}" or "${oldBranch.name}".`);
        }
    }
    else {
        if (nonInteractive) {
            throw new Error('Branch name must be specified with the --branch flag when both the --end and --non-interactive flag are true.');
        }
        endOnNewBranch = await (0, prompts_1.selectAsync)('Ending the rollout will send all traffic to a single branch. Which one should that be?', [
            {
                title: `${newBranch.name} ${chalk_1.default.grey(`- current percent: ${currentPercent}%`)}`,
                value: true,
            },
            {
                title: `${oldBranch.name} ${chalk_1.default.grey(`- current percent: ${100 - currentPercent}%`)}`,
                value: false,
            },
        ]);
    }
    if (endOnNewBranch == null) {
        throw new Error('Branch to end on is undefined.');
    }
    const newBranchMapping = {
        version: 0,
        data: [
            {
                branchId: endOnNewBranch ? newBranch.id : oldBranch.id,
                branchMappingLogic: 'true',
            },
        ],
    };
    const newChannelInfo = await (0, edit_1.updateChannelBranchMappingAsync)(graphqlClient, {
        channelId: channel.id,
        branchMapping: JSON.stringify(newBranchMapping),
    });
    const logMessage = `Rollout on channel ${chalk_1.default.bold(channelName)} ended. All traffic is now sent to branch ${chalk_1.default.bold(endOnNewBranch ? newBranch.name : oldBranch.name)}`;
    return { newChannelInfo, logMessage };
}
class ChannelRollout extends EasCommand_1.default {
    async runAsync() {
        const { args: { channel: channelNameArg }, flags: { json: jsonFlag, end: endFlag, branch: branchName, percent, 'non-interactive': nonInteractive, }, } = await this.parse(ChannelRollout);
        const { privateProjectConfig: { projectId }, loggedIn: { graphqlClient }, } = await this.getContextAsync(ChannelRollout, {
            nonInteractive,
        });
        if (jsonFlag) {
            (0, json_1.enableJsonOutput)();
        }
        const projectDisplayName = await (0, projectUtils_1.getDisplayNameForProjectIdAsync)(graphqlClient, projectId);
        let channelName = channelNameArg;
        if (!channelName) {
            const { name } = await (0, queries_2.selectChannelOnAppAsync)(graphqlClient, {
                projectId,
                selectionPromptTitle: 'Select a channel on which to perform a rollout',
                paginatedQueryOptions: {
                    json: jsonFlag,
                    nonInteractive,
                    offset: 0,
                },
            });
            channelName = name;
        }
        const channel = await ChannelQuery_1.ChannelQuery.viewUpdateChannelAsync(graphqlClient, {
            appId: projectId,
            channelName,
        });
        if (!channel) {
            throw new Error(`Could not find a channel named "${channelName}". Check which channels exist on this project with ${chalk_1.default.bold('eas channel:list')}.`);
        }
        const { branchMapping: currentBranchMapping, isRollout } = (0, utils_1.getBranchMapping)(channel.branchMapping);
        if (currentBranchMapping.data.length === 0) {
            throw new Error('The channel is not pointing at any branches.');
        }
        if (currentBranchMapping.data.length > 2) {
            throw new Error('"channel:rollout" cannot handle branch mappings with more than 2 branches.');
        }
        // This combination doesn't make sense. Throw an error explaining the options.
        if (isRollout && branchName && !endFlag) {
            throw new Error(`There is a rollout in progress. You can only either edit the rollout percent or 'end' it.`);
        }
        /**
         * This if/else block has three branches:
         *  1. The branch mapping is not a rollout, i.e. it is pointing to a single branch.
         *  2. The branch mapping is a rollout.
         *    a. increase/decrease the rollout percentage.
         *    b. end the rollout.
         */
        let rolloutMutationResult;
        if (!isRollout) {
            rolloutMutationResult = await startRolloutAsync(graphqlClient, {
                channelName,
                branchName: branchName !== null && branchName !== void 0 ? branchName : (await promptForBranchNameAsync({
                    graphqlClient,
                    projectId,
                    channelName,
                    nonInteractive,
                    json: jsonFlag,
                })),
                percent,
                nonInteractive,
                projectId,
                displayName: projectDisplayName,
                currentBranchMapping,
                channel,
            });
        }
        else if (endFlag) {
            rolloutMutationResult = await endRolloutAsync(graphqlClient, {
                channelName,
                branchName,
                nonInteractive,
                projectId,
                channel,
            });
        }
        else {
            rolloutMutationResult = await editRolloutAsync(graphqlClient, {
                channelName,
                percent,
                nonInteractive,
                currentBranchMapping,
                channel,
            });
        }
        if (!rolloutMutationResult) {
            throw new Error('rollout result is empty');
        }
        const { newChannelInfo, logMessage } = rolloutMutationResult;
        if (jsonFlag) {
            (0, json_1.printJsonOnlyOutput)(newChannelInfo);
        }
        else {
            log_1.default.withTick(logMessage);
        }
    }
}
exports.default = ChannelRollout;
_a = ChannelRollout;
ChannelRollout.description = 'Roll a new branch out on a channel incrementally.';
ChannelRollout.args = [
    {
        name: 'channel',
        description: 'channel on which the rollout should be done',
    },
];
ChannelRollout.flags = {
    branch: core_1.Flags.string({
        description: 'branch to rollout',
        required: false,
    }),
    percent: core_1.Flags.integer({
        description: 'percent of users to send to the new branch',
        required: false,
    }),
    end: core_1.Flags.boolean({
        description: 'end the rollout',
        default: false,
    }),
    ...flags_1.EasNonInteractiveAndJsonFlags,
};
ChannelRollout.contextDefinition = {
    ..._a.ContextOptions.ProjectConfig,
    ..._a.ContextOptions.LoggedIn,
};
async function promptForBranchNameAsync({ graphqlClient, projectId, channelName, nonInteractive, json, }) {
    if (nonInteractive) {
        throw new Error('Must supply branch flag in non-interactive mode');
    }
    const { name: branchName } = await (0, queries_1.selectBranchOnAppAsync)(graphqlClient, {
        projectId,
        promptTitle: `Which branch would you like roll out on ${channelName}?`,
        displayTextForListItem: updateBranch => ({
            title: updateBranch.name,
        }),
        // discard limit and offset because this query is not their intended target
        paginatedQueryOptions: {
            json,
            nonInteractive,
            offset: 0,
        },
    });
    return branchName;
}
