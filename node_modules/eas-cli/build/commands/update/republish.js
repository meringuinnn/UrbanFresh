"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const url_1 = require("../../build/utils/url");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const pagination_1 = require("../../commandUtils/pagination");
const PublishMutation_1 = require("../../graphql/mutations/PublishMutation");
const UpdateQuery_1 = require("../../graphql/queries/UpdateQuery");
const log_1 = tslib_1.__importStar(require("../../log"));
const ora_1 = require("../../ora");
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
const getBranchNameFromChannelNameAsync_1 = require("../../update/getBranchNameFromChannelNameAsync");
const queries_1 = require("../../update/queries");
const utils_1 = require("../../update/utils");
const formatFields_1 = tslib_1.__importDefault(require("../../utils/formatFields"));
const json_1 = require("../../utils/json");
const defaultRepublishPlatforms = ['android', 'ios'];
class UpdateRepublish extends EasCommand_1.default {
    async runAsync() {
        const { flags: rawFlags } = await this.parse(UpdateRepublish);
        const flags = this.sanitizeFlags(rawFlags);
        const { privateProjectConfig: { exp, projectId }, loggedIn: { graphqlClient }, } = await this.getContextAsync(UpdateRepublish, {
            nonInteractive: flags.nonInteractive,
        });
        if (flags.json) {
            (0, json_1.enableJsonOutput)();
        }
        const existingUpdates = await getOrAskUpdatesAsync(graphqlClient, projectId, flags);
        const updatesToPublish = existingUpdates.filter(update => flags.platform.includes(update.platform));
        if (existingUpdates.length === 0) {
            throw new Error(`There are no published updates found`);
        }
        if (updatesToPublish.length === 0) {
            throw new Error(`There are no updates on branch "${existingUpdates[0].branchName}" published for the platform(s) "${rawFlags.platform}" with group ID "${flags.groupId ? flags.groupId : updatesToPublish[0].groupId}". Did you mean to publish a new update instead?`);
        }
        if (rawFlags.platform === 'all') {
            log_1.default.withTick(`The republished update will appear only on: ${rawFlags.platform}`);
        }
        else {
            const platformsFromUpdates = updatesToPublish.map(update => update.platform);
            if (platformsFromUpdates.length < defaultRepublishPlatforms.length) {
                log_1.default.warn(`You are republishing an update that wasn't published for all platforms.`);
            }
            log_1.default.withTick(`The republished update will appear on the same platforms it was originally published on: ${platformsFromUpdates.join(', ')}`);
        }
        // This command only republishes a single update group
        // The update group properties are the same for all updates
        const { branchId, branchName, runtimeVersion } = updatesToPublish[0];
        const updateMessage = await getOrAskUpdateMessageAsync(updatesToPublish, flags);
        // If codesigning was created for the original update, we need to add it to the republish
        const shouldRepublishWithCodesigning = updatesToPublish.some(update => update.codeSigningInfo);
        if (shouldRepublishWithCodesigning) {
            log_1.default.withTick(`The republished update will be signed with the same codesigning as the original update.`);
        }
        const publishIndicator = (0, ora_1.ora)('Republishing...').start();
        let updatesRepublished;
        try {
            updatesRepublished = await PublishMutation_1.PublishMutation.publishUpdateGroupAsync(graphqlClient, [
                {
                    branchId,
                    runtimeVersion,
                    message: updateMessage,
                    updateInfoGroup: Object.fromEntries(updatesToPublish.map(update => [update.platform, JSON.parse(update.manifestFragment)])),
                    gitCommitHash: updatesToPublish[0].gitCommitHash,
                    awaitingCodeSigningInfo: shouldRepublishWithCodesigning,
                },
            ]);
            if (shouldRepublishWithCodesigning) {
                const codeSigningByPlatform = Object.fromEntries(updatesToPublish.map(update => [update.platform, update.codeSigningInfo]));
                await Promise.all(updatesRepublished.map(async (update) => {
                    const codeSigning = codeSigningByPlatform[update.platform];
                    if (codeSigning) {
                        await PublishMutation_1.PublishMutation.setCodeSigningInfoAsync(graphqlClient, update.id, codeSigning);
                    }
                }));
            }
            publishIndicator.succeed('Republished update');
        }
        catch (error) {
            publishIndicator.fail('Failed to republish update');
            throw error;
        }
        if (flags.json) {
            return (0, json_1.printJsonOnlyOutput)(updatesRepublished);
        }
        const updatesRepublishedByPlatform = Object.fromEntries(updatesRepublished.map(update => [update.platform, update]));
        const updateGroupUrl = (0, url_1.getUpdateGroupUrl)((await (0, projectUtils_1.getOwnerAccountForProjectIdAsync)(graphqlClient, projectId)).name, exp.slug, updatesRepublished[0].group);
        log_1.default.addNewLineIfNone();
        log_1.default.log((0, formatFields_1.default)([
            { label: 'Branch', value: branchName },
            { label: 'Runtime version', value: updatesRepublished[0].runtimeVersion },
            { label: 'Platform', value: updatesRepublished.map(update => update.platform).join(', ') },
            { label: 'Update Group ID', value: updatesRepublished[0].id },
            ...(updatesRepublishedByPlatform.android
                ? [{ label: 'Android update ID', value: updatesRepublishedByPlatform.android.id }]
                : []),
            ...(updatesRepublishedByPlatform.ios
                ? [{ label: 'iOS update ID', value: updatesRepublishedByPlatform.ios.id }]
                : []),
            { label: 'Message', value: updateMessage },
            { label: 'Website link', value: (0, log_1.link)(updateGroupUrl, { dim: false }) },
        ]));
    }
    sanitizeFlags(rawFlags) {
        var _b;
        const branchName = rawFlags.branch;
        const channelName = rawFlags.channel;
        const groupId = rawFlags.group;
        const nonInteractive = rawFlags['non-interactive'];
        if (nonInteractive && !groupId) {
            throw new Error('Only --group can be used in non-interactive mode');
        }
        if (!groupId && !(branchName || channelName)) {
            throw new Error(`--channel, --branch, or --group must be specified`);
        }
        const platform = rawFlags.platform === 'all' ? defaultRepublishPlatforms : [rawFlags.platform];
        return {
            branchName,
            channelName,
            groupId,
            platform,
            updateMessage: rawFlags.message,
            json: (_b = rawFlags.json) !== null && _b !== void 0 ? _b : false,
            nonInteractive,
        };
    }
}
exports.default = UpdateRepublish;
_a = UpdateRepublish;
UpdateRepublish.description = 'roll back to an existing update';
UpdateRepublish.flags = {
    channel: core_1.Flags.string({
        description: 'Channel name to select an update to republish from',
        exclusive: ['branch', 'group'],
    }),
    branch: core_1.Flags.string({
        description: 'Branch name to select an update to republish from',
        exclusive: ['channel', 'group'],
    }),
    group: core_1.Flags.string({
        description: 'Update group ID to republish',
        exclusive: ['branch', 'channel'],
    }),
    message: core_1.Flags.string({
        description: 'Short message describing the republished update',
        required: false,
    }),
    platform: core_1.Flags.enum({
        char: 'p',
        options: [...defaultRepublishPlatforms, 'all'],
        default: 'all',
        required: false,
    }),
    ...flags_1.EasNonInteractiveAndJsonFlags,
};
UpdateRepublish.contextDefinition = {
    ..._a.ContextOptions.ProjectConfig,
    ..._a.ContextOptions.LoggedIn,
};
/** Retrieve the update group from either the update group id, or select from branch name. */
async function getOrAskUpdatesAsync(graphqlClient, projectId, flags) {
    if (flags.groupId) {
        const updateGroups = await UpdateQuery_1.UpdateQuery.viewUpdateGroupAsync(graphqlClient, {
            groupId: flags.groupId,
        });
        return updateGroups.map(group => ({
            ...group,
            groupId: group.group,
            branchId: group.branch.id,
            branchName: group.branch.name,
        }));
    }
    if (flags.branchName) {
        return await askUpdatesFromBranchNameAsync(graphqlClient, {
            ...flags,
            branchName: flags.branchName,
            projectId,
        });
    }
    if (flags.channelName) {
        return await askUpdatesFromChannelNameAsync(graphqlClient, {
            ...flags,
            channelName: flags.channelName,
            projectId,
        });
    }
    throw new Error('--channel, --branch, or --group is required');
}
/** Ask the user which update needs to be republished by branch name, this requires interactive mode */
async function askUpdatesFromBranchNameAsync(graphqlClient, { projectId, branchName, json, nonInteractive, }) {
    if (nonInteractive) {
        throw new Error('Must supply --group when in non-interactive mode');
    }
    const updateGroups = await (0, queries_1.selectUpdateGroupOnBranchAsync)(graphqlClient, {
        projectId,
        branchName,
        paginatedQueryOptions: (0, pagination_1.getPaginatedQueryOptions)({ json, 'non-interactive': nonInteractive }),
    });
    return updateGroups.map(group => ({
        ...group,
        groupId: group.id,
        branchId: group.branch.id,
        branchName: group.branch.name,
    }));
}
/** Ask the user which update needs to be republished by channel name, this requires interactive mode */
async function askUpdatesFromChannelNameAsync(graphqlClient, { projectId, channelName, json, nonInteractive, }) {
    if (nonInteractive) {
        throw new Error('Must supply --group when in non-interactive mode');
    }
    const branchName = await (0, getBranchNameFromChannelNameAsync_1.getBranchNameFromChannelNameAsync)(graphqlClient, projectId, channelName);
    return await askUpdatesFromBranchNameAsync(graphqlClient, {
        projectId,
        branchName,
        json,
        nonInteractive,
    });
}
/** Get or ask the user for the update (group) message for the republish */
async function getOrAskUpdateMessageAsync(updates, flags) {
    if (flags.updateMessage) {
        return sanitizeUpdateMessage(flags.updateMessage);
    }
    if (flags.nonInteractive || flags.json) {
        throw new Error('Must supply --message when in non-interactive mode');
    }
    // This command only uses a single update group to republish, meaning these values are always identical
    const oldGroupId = updates[0].groupId;
    const oldUpdateMessage = updates[0].message;
    const { updateMessage } = await (0, prompts_1.promptAsync)({
        type: 'text',
        name: 'updateMessage',
        message: 'Provide an update message.',
        initial: `Republish "${oldUpdateMessage}" - group: ${oldGroupId}`,
        validate: (value) => (value ? true : 'Update message may not be empty.'),
    });
    return sanitizeUpdateMessage(updateMessage);
}
function sanitizeUpdateMessage(updateMessage) {
    if (updateMessage !== (0, utils_1.truncateString)(updateMessage, 1024)) {
        log_1.default.warn('Update message exceeds the allowed 1024 character limit, truncated update message.');
        return (0, utils_1.truncateString)(updateMessage, 1024);
    }
    return updateMessage;
}
